\documentclass[a4paper, 11pt]{article}
\usepackage{comment}
\usepackage{fullpage}
\usepackage{todonotes}
\usepackage{hyperref}

\begin{document}
%Header-Make sure you update this information!!!!
\noindent
\large\textbf{VoidPhone Project} \hfill \textbf{Initial Report} \\
\normalsize P2PSEC (IN2194)  \hfill Team 20 - Calcium\\
Prof. Dr.-Ing Georg Carle \hfill Maximilian Schäffeler, Simon Ellmann \\
Sree Harsha Totakura, Richard von Seck \hfill Due Date: 05/26/19

% TODO
% 2. List at least 3 shortcomings of the implementation
% 3. Address how you intend to address these shortcomings
% 4. Do you know of a better design to tweak the implementation?

\section*{Team Composition}
We are Maximilian Schäffeler and Simon Ellmann, both studying Informatics in our Masters'.
As a team name we chose ``Calcium'' \footnote{Calcium is the element with atomic number 0x14.} and will be working on the Distributed Hash Table (DHT) project written in Rust \cite{Rust} in 2018 by Benedikt Seidl and Stefan Su aka team ``Rhodium''.


\section*{Assessment of the Implementation}
\subsection*{Module Functional Logic}
Grading: $\circ$\\
\\
The part of the implementation that decides whether a peer is responsible for a key is faulty in the edge case where there exists only a single peer.
In the current state, the single client denies responsibility for all keys, where it actually is responsible for all of them.
After fixing this bug, the rest of the implementation works as expected for a static network of peers.

Key-value pairs are not redistributed between peers when nodes join or leave. Thus the peer network has to be built up before any data may be stored.
Data for a key is currently only stored with a single peer, the replication index is not taken into account.

\subsection*{Security Measures}
Grading: $\circ$\\
\\
No explicit security measures are implemented yet.
The most important attack mechanism against DHTs are Sybil attacks, where a large number of peers is under control of a singly entity. 
These peers may then report faulty routing information or altered values. 
Ultimately, those abilities can be abused for an Eclipse attack or may lead to data loss.
In its current state, the project offers very basic protection against Sybil attacks as the id of all peers are derived from their IP address, which are a relatively scarce resource (considering IPv4).

Furthermore, forged PUT messages by attackers may be used to overwrite existing data.
A possible solution is to require PUT messages to be signed.
There is currently no load balancing among peers for each specific key-value pair. 
Using replication of data and a less deterministic key lookup, denial of service attacks that send a large number of requests for a single key would be harder to carry out.

To counter Sibyl attacks, we plan to implement plausibility checks for IDs in the routing table.
We will also assess if a proof of work required to join the network can further improve the situation.
Effective protection against Sibyl attacks for DHTs is non-trivial.
There exists a survey of possible countermeasures \cite{urdaneta2011survey}, but each comes with a different set of drawbacks.


\subsection*{P2P Protocol}
Grading: $+$\\
\\
All neccessary P2P messages for Chord are already fully implemented and working.
As described above, the protocol is not yet robust against misbehaving peers and more advanced features of Chord are missing. 
The P2P messages are well-designed and simple.


\subsection*{API}
Grading: $+$\\
\\
The existing implementation offers a simple REPL to interact with the DHT via API messages.
All API messages are implemented.


\subsection*{Asynchronous IO}
Grading: $\circ$\\
\\
The project does not yet make use of async functionality in Rust.
A thread pool is used instead to handle multiple concurrent requests.


\subsection*{Message Formats}
Grading: $+$\\
\\
Both the API messages and P2P messages have a simple, easy to parse structure.
There is some duplicated code for each message type, which we will try to minimize using traits.


\subsection*{Tests}
Grading: $+$\\
\\
Overall there are 39 test cases included in the project.
Most of the existing test cases assert correctness of the byte representation of different message types and parsing of bytes into messages.
Unfortunately, there are no runtime tests that verify whether data is properly stored in and retrieved from the distributed hash table.
However, the implementation offers a Vagrant setup to spin up VMs that then automatically run the DHT.
We plan on improving the setup to allow automatic testing.

\subsection*{Coding Style}
Grading: $+$\\
\\
Coding style of the implementation is mostly consistent and reputable.
Unfortunately, formatting is contrary to the Rust Style Guide \cite{RustStyleGuide} in some places.


\subsection*{Documentation}
Grading: $++$\\
\\
The implementation is very well documented.
Every submodule contains a more or less detailed description about the module.
There are many inline comments on used data types and methods.
Additionally, every major function contains logging information to facilitate debugging of the implementation.


\subsection*{Subsumption}
Overall Grading: $+$\\
\\
The implementation offers a solid foundation for implementing the remaining features of a DHT according to the Chord protocol. 
A lot of thought has been put in to create a project that is extensible.

\section*{Plans to improve the Implementation}
We will mainly focus on the following topics/flaws to improve the existing implementation:

\begin{itemize}
	\item Functional logic (no data replication, no new peers allowed after setup, ...)
	\item Testing (no runtime tests, ...)
	\item Security measures (no defense against sibyl attacks and forged messages, ...)
\end{itemize}

We will implement the remaining parts of the chord algorithm as described in \cite{stoica2001chord}, which mostly concerns peers dynamically joining and leaving the network. 
While fixing the logic flaws we will verify correctness of the program by adding more test cases and creating a test setup based on virtual machines that can be automatically executed.
Depending on the needed amount of time for the previous tasks we might still try to add security measures to the implementation like signing of messages and various plausbility checks for information in the routing tables.


\section*{Dependencies of the Implementation}
All dependencies used by the implementation are deprecated and can be updated to newer versions.\\
The specified version of the \texttt{ring} \cite{CratesIORing} crate used to generate SHA256 hashes is not available anymore since the maintainer of this crate has yanked (i.e. removed) all previous versions of the crate from the Rust Package Registry \texttt{crates.io} \cite{CratesIO} and continues to do so to indicate that previous versions are no longer supported\footnote{\url{https://github.com/briansmith/ring/issues/774}}.
Unfortunately, the maintainer of \texttt{ring} does not understand that previous versions of a crate should never be removed from \texttt{crates.io} except in case of grave mistakes like security vulnerabilities or syntax errors because libraries depending on yanked crates cannot be built anymore as it is the case for this implementation.
Since the maintainer of \texttt{ring} will yank versions of his crate in the future, this crate is not a reasonable choice for a library.
We suggest to replace the dependency by either \texttt{rust-crypto} \cite{CratesIOCrypto} or \texttt{sha2} \cite{CratesIOSha2}.\\
All other dependencies seem to be reasonable choices.

\section*{Workload Sharing}
Simon is the more experienced Rustacean, having implemented a user space network driver in Rust \cite{Ixy}.
Nevertheless, we will share the workload equally by focusing on different aspects. 
Maximilian will be responsible for providing a more elaborate testing setup and fixing flaws in the existing codebase. 
To produce high-quality software, Simon will work to ensure all new and existing code adheres to the standards of idiomatic Rust.
During the whole project we will communicate, especially when implementing new features and before making major design decisions.

\bibliographystyle{IEEEtran}
\bibliography{../bibliography}

\end{document}
